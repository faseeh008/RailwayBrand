import jsPDF from 'jspdf';
// Commented out to avoid bundling in Vercel serverless functions (exceeds 250MB limit)
// Uncomment if deploying to a platform that supports larger bundles (e.g., Railway, Render)
// import html2canvas from 'html2canvas';

export interface ExportOptions {
	brandName: string;
	content: string;
	includeMetadata?: boolean;
	metadata?: {
		industry?: string;
		mood?: string;
		audience?: string;
		createdAt?: Date;
	};
	logoPath?: string;
}

export function exportAsPDF(options: ExportOptions): void {
	const { brandName, content, includeMetadata = true, metadata, logoPath } = options;

	// Create a temporary container for the content
	const tempContainer = document.createElement('div');
	tempContainer.style.position = 'absolute';
	tempContainer.style.left = '-9999px';
	tempContainer.style.top = '0';
	tempContainer.style.width = '800px';
	tempContainer.style.padding = '40px';
	tempContainer.style.backgroundColor = '#ffffff';
	tempContainer.style.fontFamily = 'Arial, sans-serif';
	tempContainer.style.fontSize = '12px';
	tempContainer.style.lineHeight = '1.6';
	tempContainer.style.color = '#333333';
	tempContainer.style.border = 'none';
	tempContainer.style.outline = 'none';
	tempContainer.style.boxShadow = 'none';

	// Add content to container with inline styles to avoid CSS conflicts
	tempContainer.innerHTML = formatContentForPDF(
		content,
		brandName,
		includeMetadata,
		metadata,
		logoPath
	);

	// Add to document temporarily
	document.body.appendChild(tempContainer);

	// Generate PDF with safer options
	html2canvas(tempContainer, {
		scale: 1.5,
		useCORS: false,
		backgroundColor: '#ffffff',
		allowTaint: false,
		foreignObjectRendering: false,
		logging: false,
		width: 800,
		height: tempContainer.scrollHeight
	})
		.then((canvas) => {
			const imgData = canvas.toDataURL('image/png');
			const pdf = new jsPDF('p', 'mm', 'a4');

			const imgWidth = 210; // A4 width in mm
			const pageHeight = 295; // A4 height in mm
			const imgHeight = (canvas.height * imgWidth) / canvas.width;
			let heightLeft = imgHeight;

			let position = 0;

			// Add first page
			pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
			heightLeft -= pageHeight;

			// Add additional pages if needed
			while (heightLeft >= 0) {
				position = heightLeft - imgHeight;
				pdf.addPage();
				pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
				heightLeft -= pageHeight;
			}

			// Save the PDF
			const fileName = `${brandName.replace(/[^a-zA-Z0-9]/g, '_')}_Brand_Guidelines.pdf`;
			pdf.save(fileName);

			// Clean up
			document.body.removeChild(tempContainer);
		})
		.catch((error) => {
			console.error('Error generating PDF:', error);

			// Fallback: Try with a simpler approach
			try {
				generateSimplePDF(options);
			} catch (fallbackError) {
				console.error('Fallback PDF generation also failed:', fallbackError);
				alert('Error generating PDF. Please try again or use the text export option.');
			}

			document.body.removeChild(tempContainer);
		});
}

export function exportAsText(options: ExportOptions): void {
	const { brandName, content, includeMetadata = true, metadata } = options;

	let textContent = '';

	// Add header
	textContent += `${brandName.toUpperCase()} BRAND GUIDELINES\n`;
	textContent += '='.repeat(brandName.length + 20) + '\n';
	textContent += 'Comprehensive Brand Identity & Design Guidelines\n';
	textContent += '='.repeat(brandName.length + 20) + '\n\n';

	// Add metadata if requested
	if (includeMetadata && metadata) {
		textContent += 'BRAND INFORMATION\n';
		textContent += '-'.repeat(20) + '\n';
		if (metadata.industry) textContent += `Industry: ${metadata.industry}\n`;
		if (metadata.mood) textContent += `Brand Mood: ${metadata.mood}\n`;
		if (metadata.audience) textContent += `Target Audience: ${metadata.audience}\n`;
		if (metadata.createdAt) textContent += `Created: ${metadata.createdAt.toLocaleDateString()}\n`;
		textContent += '\n';
	}

	// Add main content (strip HTML tags and format, but preserve color codes and typography info)
	const cleanContent = content
		.replace(/<[^>]*>/g, '') // Remove HTML tags
		.replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markers
		.replace(/\*(.*?)\*/g, '$1') // Remove italic markers
		.replace(/#{1,6}\s*/g, '') // Remove markdown headers
		.replace(/\n{3,}/g, '\n\n') // Clean up multiple line breaks
		.trim();

	// Integrate color and typography information into the content sections
	textContent += integrateVisualElementsIntoText(content);

	// Add footer
	textContent += '\n\n' + '='.repeat(50) + '\n';
	textContent += `Generated by AI Brand Guideline Assistant\n`;
	textContent += `Generated on: ${new Date().toLocaleDateString()}\n`;

	// Create and download file
	const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
	const url = URL.createObjectURL(blob);
	const link = document.createElement('a');
	link.href = url;
	link.download = `${brandName.replace(/[^a-zA-Z0-9]/g, '_')}_Brand_Guidelines.txt`;
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
	URL.revokeObjectURL(url);
}

function formatContentForPDF(
	content: string,
	brandName: string,
	includeMetadata: boolean,
	metadata?: any,
	logoPath?: string
): string {
	let html = `
		<div style="text-align: center; margin-bottom: 30px;">
			<h1 style="font-size: 24px; font-weight: bold; color: #333333; margin-bottom: 10px;">${brandName.toUpperCase()}</h1>
			<h2 style="font-size: 18px; color: #666666; margin-bottom: 5px;">BRAND GUIDELINES</h2>
			<p style="font-size: 14px; color: #888888; margin-bottom: 20px;">Comprehensive Brand Identity & Design Guidelines</p>
		</div>
	`;

	if (includeMetadata && metadata) {
		html += `
			<div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #e9ecef;">
				<h3 style="font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #333333;">Brand Information</h3>
				<div style="font-size: 12px; color: #666666;">
		`;
		if (metadata.industry)
			html += `<p style="margin: 4px 0;"><strong>Industry:</strong> ${metadata.industry}</p>`;
		if (metadata.mood)
			html += `<p style="margin: 4px 0;"><strong>Brand Mood:</strong> ${metadata.mood}</p>`;
		if (metadata.audience)
			html += `<p style="margin: 4px 0;"><strong>Target Audience:</strong> ${metadata.audience}</p>`;
		if (metadata.createdAt)
			html += `<p style="margin: 4px 0;"><strong>Created:</strong> ${metadata.createdAt.toLocaleDateString()}</p>`;
		html += `
				</div>
			</div>
		`;
	}

	// Format the main content with explicit hex colors and integrate visual elements
	let formattedContent = content
		// Convert markdown images to HTML img tags (simple centered logo like in image)
		.replace(
			/!\[([^\]]*)\]\(([^)]+)\)/g,
			'<div style="margin: 20px 0; text-align: center;"><img src="$2" alt="$1" style="max-height: 80px; max-width: 256px; object-fit: contain;" /></div>'
		)
		.replace(
			/^# (.*$)/gim,
			'<h1 style="font-size: 20px; font-weight: bold; color: #333333; margin: 20px 0 10px 0;">$1</h1>'
		)
		.replace(
			/^## (.*$)/gim,
			'<h2 style="font-size: 16px; font-weight: bold; color: #333333; margin: 15px 0 8px 0;">$1</h2>'
		)
		.replace(
			/^### (.*$)/gim,
			'<h3 style="font-size: 14px; font-weight: bold; color: #333333; margin: 12px 0 6px 0;">$1</h3>'
		)
		.replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: bold; color: #333333;">$1</strong>')
		.replace(/\*(.*?)\*/g, '<em style="font-style: italic; color: #333333;">$1</em>')
		.replace(
			/^\* (.*$)/gim,
			'<li style="margin: 4px 0; margin-left: 20px; color: #333333;">$1</li>'
		)
		.replace(/^- (.*$)/gim, '<li style="margin: 4px 0; margin-left: 20px; color: #333333;">$1</li>')
		.replace(/\n\n/g, '</p><p style="margin: 8px 0; line-height: 1.6; color: #333333;">')
		.replace(/\n/g, '<br>')
		.replace(/^(.*)$/gm, '<p style="margin: 8px 0; line-height: 1.6; color: #333333;">$1</p>')
		.replace(/<p style="margin: 8px 0; line-height: 1.6; color: #333333;"><\/p>/g, '')
		.replace(
			/<p style="margin: 8px 0; line-height: 1.6; color: #333333;">(<h[1-6][^>]*>.*<\/h[1-6]>)<\/p>/g,
			'$1'
		)
		.replace(
			/<p style="margin: 8px 0; line-height: 1.6; color: #333333;">(<li[^>]*>.*<\/li>)<\/p>/g,
			'$1'
		)
		.replace(
			/<p style="margin: 8px 0; line-height: 1.6; color: #333333;">(<img[^>]*>)<\/p>/g,
			'$1'
		);

	// Integrate logo into logo guidelines sections
	formattedContent = integrateLogoIntoGuidelines(formattedContent, logoPath);

	// Integrate color swatches into color palette sections
	formattedContent = integrateColorSwatches(formattedContent);

	// Integrate typography showcases into typography sections
	formattedContent = integrateTypographyShowcases(formattedContent);

	html += formattedContent;

	html += `
		<div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #dddddd; text-align: center; font-size: 10px; color: #999999;">
			<p style="margin: 4px 0;">Generated by AI Brand Guideline Assistant</p>
			<p style="margin: 4px 0;">Generated on: ${new Date().toLocaleDateString()}</p>
		</div>
	`;

	return html;
}

function generateSimplePDF(options: ExportOptions): void {
	const { brandName, content, includeMetadata = true, metadata, logoPath } = options;

	// Create a simple PDF without html2canvas
	const pdf = new jsPDF('p', 'mm', 'a4');
	const pageWidth = 210;
	const pageHeight = 295;
	const margin = 20;
	const lineHeight = 6;
	let yPosition = margin;

	// Helper function to add text with word wrapping
	function addText(text: string, fontSize: number = 12, isBold: boolean = false) {
		pdf.setFontSize(fontSize);
		if (isBold) {
			pdf.setFont('helvetica', 'bold');
		} else {
			pdf.setFont('helvetica', 'normal');
		}

		const lines = pdf.splitTextToSize(text, pageWidth - 2 * margin);
		for (const line of lines) {
			if (yPosition > pageHeight - margin) {
				pdf.addPage();
				yPosition = margin;
			}
			pdf.text(line, margin, yPosition);
			yPosition += lineHeight;
		}
	}

	// Add header
	addText(brandName.toUpperCase(), 20, true);
	yPosition += 5;
	addText('BRAND GUIDELINES', 16, true);
	yPosition += 3;
	addText('Comprehensive Brand Identity & Design Guidelines', 12);
	yPosition += 10;

	// Add metadata if requested
	if (includeMetadata && metadata) {
		addText('Brand Information', 14, true);
		yPosition += 5;
		if (metadata.industry) addText(`Industry: ${metadata.industry}`);
		if (metadata.mood) addText(`Brand Mood: ${metadata.mood}`);
		if (metadata.audience) addText(`Target Audience: ${metadata.audience}`);
		if (metadata.createdAt) addText(`Created: ${metadata.createdAt.toLocaleDateString()}`);
		yPosition += 10;
	}

	// Add main content (strip HTML and format) with integrated visual elements
	const cleanContent = integrateVisualElementsIntoText(content);

	// Split content into sections and add to PDF
	const sections = cleanContent.split('\n\n');
	for (const section of sections) {
		if (section.trim()) {
			// Check if it's a header (all caps or starts with number)
			if (section.match(/^[A-Z\s\d\.]+$/) || section.match(/^\d+\./)) {
				addText(section, 14, true);
			} else {
				addText(section);
			}
			yPosition += 3;
		}
	}

	// Add footer
	yPosition = pageHeight - 20;
	addText('Generated by AI Brand Guideline Assistant', 10);
	addText(`Generated on: ${new Date().toLocaleDateString()}`, 10);

	// Save the PDF
	const fileName = `${brandName.replace(/[^a-zA-Z0-9]/g, '_')}_Brand_Guidelines.pdf`;
	pdf.save(fileName);
}

// Helper function to extract color information from content
function extractColorInformation(content: string): Array<{
	name: string;
	hex: string;
	rgb: string;
	cmyk: string;
	usage: string;
}> {
	const colors: Array<{ name: string; hex: string; rgb: string; cmyk: string; usage: string }> = [];

	// Extract hex codes from content
	const hexMatches = content.match(/#[0-9A-Fa-f]{6}/g);
	if (hexMatches) {
		hexMatches.forEach((hex, index) => {
			const colorName = getColorNameFromHex(hex);
			colors.push({
				name: colorName,
				hex: hex.toUpperCase(),
				rgb: hexToRgb(hex),
				cmyk: hexToCmyk(hex),
				usage: getColorUsage(index)
			});
		});
	}

	return colors;
}

// Helper function to extract typography information from content
function extractTypographyInformation(content: string): Array<{
	name: string;
	usage: string;
	weights: string;
	sample: string;
}> {
	const fonts: Array<{ name: string; usage: string; weights: string; sample: string }> = [];

	// Look for font mentions in the content
	const fontMatches = content.match(/([A-Za-z\s]+)(?:\s*\([^)]*\))?/g);
	if (fontMatches) {
		const cleanFonts = fontMatches
			.filter(
				(font) =>
					font.length > 3 &&
					font.length < 30 &&
					!font.includes('font') &&
					!font.includes('size') &&
					!font.includes('weight') &&
					!font.includes('color') &&
					!font.includes('brand')
			)
			.slice(0, 2);

		cleanFonts.forEach((font, index) => {
			fonts.push({
				name: font.trim(),
				usage: index === 0 ? 'Primary Font (Headings)' : 'Secondary Font (Body Text)',
				weights: 'Regular, Medium, Bold',
				sample: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 1234567890'
			});
		});
	}

	return fonts;
}

// Helper function to get color name from hex
function getColorNameFromHex(hex: string): string {
	const colorMap: { [key: string]: string } = {
		'#FFA500': 'Orange',
		'#007FFF': 'Blue',
		'#90EE90': 'Green',
		'#FFD700': 'Yellow',
		'#F5F5F5': 'Off-White',
		'#FF0000': 'Red',
		'#800080': 'Purple',
		'#000000': 'Black',
		'#FFFFFF': 'White',
		'#808080': 'Gray',
		'#00A699': 'Teal',
		'#F2F2F2': 'Light Gray',
		'#64B5F6': 'Light Blue',
		'#A7D1AB': 'Light Green',
		'#8BC34A': 'Green'
	};
	return colorMap[hex.toUpperCase()] || `Color ${hex.toUpperCase()}`;
}

// Helper function to convert hex to RGB
function hexToRgb(hex: string): string {
	const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	if (result) {
		const r = parseInt(result[1], 16);
		const g = parseInt(result[2], 16);
		const b = parseInt(result[3], 16);
		return `${r}, ${g}, ${b}`;
	}
	return '0, 0, 0';
}

// Helper function to convert hex to CMYK
function hexToCmyk(hex: string): string {
	const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	if (result) {
		const r = parseInt(result[1], 16) / 255;
		const g = parseInt(result[2], 16) / 255;
		const b = parseInt(result[3], 16) / 255;

		const k = 1 - Math.max(r, g, b);
		const c = (1 - r - k) / (1 - k) || 0;
		const m = (1 - g - k) / (1 - k) || 0;
		const y = (1 - b - k) / (1 - k) || 0;

		return `${Math.round(c * 100)}%, ${Math.round(m * 100)}%, ${Math.round(y * 100)}%, ${Math.round(k * 100)}%`;
	}
	return '0%, 0%, 0%, 100%';
}

// Helper function to get color usage description
function getColorUsage(index: number): string {
	const usages = [
		'Primary brand color - use for main elements, logos, and key highlights',
		'Secondary color - use for supporting elements and accents',
		'Accent color - use sparingly for highlights and call-to-action elements',
		'Neutral color - use for backgrounds, text, and subtle elements',
		'Background color - use for page backgrounds and large areas',
		'Text color - use for body text and readable content'
	];
	return usages[index] || 'Supporting color - use as needed for brand consistency';
}

// Helper function to integrate color swatches into color palette sections
function integrateColorSwatches(content: string): string {
	const colorInfo = extractColorInformation(content);
	if (colorInfo.length === 0) return content;

	// Look for color palette sections and add visual swatches
	return content.replace(
		/(<h[2-3][^>]*>.*[Cc]olor.*[Pp]alette.*<\/h[2-3]>.*?)(<h[2-3]|$)/gs,
		(match, colorSection, nextSection) => {
			// Create color swatches HTML
			const colorSwatches = colorInfo
				.map(
					(color) => `
				<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 5px; background-color: #f9f9f9;">
					<div style="width: 40px; height: 40px; border-radius: 5px; border: 2px solid #ddd; background-color: ${color.hex};"></div>
					<div>
						<div style="font-weight: bold; color: #333333; font-size: 14px;">${color.name}</div>
						<div style="font-size: 12px; color: #666666; font-family: monospace;">${color.hex}</div>
						<div style="font-size: 11px; color: #888888;">RGB: ${color.rgb}</div>
						<div style="font-size: 11px; color: #888888;">CMYK: ${color.cmyk}</div>
					</div>
				</div>
			`
				)
				.join('');

			// Insert color swatches after the first paragraph in the color section
			return (
				colorSection.replace(
					/(<p style="margin: 8px 0; line-height: 1.6; color: #333333;">.*?<\/p>)/s,
					`$1<div style="margin-top: 15px; margin-bottom: 20px;"><h4 style="font-size: 14px; font-weight: bold; color: #333333; margin-bottom: 10px;">Color Swatches</h4><div style="display: flex; flex-wrap: wrap; gap: 15px;">${colorSwatches}</div></div>`
				) + nextSection
			);
		}
	);
}

// Helper function to integrate typography showcases into typography sections
function integrateTypographyShowcases(content: string): string {
	const typographyInfo = extractTypographyInformation(content);
	if (typographyInfo.length === 0) return content;

	// Look for typography sections and add font showcases
	return content.replace(
		/(<h[2-3][^>]*>.*[Tt]ypography.*<\/h[2-3]>.*?)(<h[2-3]|$)/gs,
		(match, typographySection, nextSection) => {
			// Create typography showcase HTML
			const typographyShowcase = typographyInfo
				.map(
					(font) => `
				<div style="margin-bottom: 20px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 5px; background-color: #f9f9f9;">
					<div style="font-weight: bold; color: #333333; font-size: 14px; margin-bottom: 5px;">${font.name}</div>
					<div style="font-size: 12px; color: #666666; margin-bottom: 10px;">${font.usage}</div>
					<div style="font-size: 12px; color: #666666; margin-bottom: 10px;">Weights: ${font.weights}</div>
					<div style="font-size: 16px; color: #333333; font-family: '${font.name}', serif; line-height: 1.4;">
						${font.sample}
					</div>
				</div>
			`
				)
				.join('');

			// Insert typography showcase after the first paragraph in the typography section
			return (
				typographySection.replace(
					/(<p style="margin: 8px 0; line-height: 1.6; color: #333333;">.*?<\/p>)/s,
					`$1<div style="margin-top: 15px; margin-bottom: 20px;"><h4 style="font-size: 14px; font-weight: bold; color: #333333; margin-bottom: 10px;">Font Showcase</h4>${typographyShowcase}</div>`
				) + nextSection
			);
		}
	);
}

// Helper function to integrate logo into logo guidelines sections
function integrateLogoIntoGuidelines(content: string, logoPath?: string): string {
	if (!logoPath) return content;

	// Look for logo guidelines sections and add logo display
	return content.replace(
		/(<h[2-3][^>]*>.*[Ll]ogo.*[Gg]uidelines.*<\/h[2-3]>.*?)(<h[2-3]|$)/gs,
		(match, logoSection, nextSection) => {
			// Create simple centered logo display HTML
			const logoDisplay = `
				<div style="margin: 20px 0; text-align: center;">
					<img src="${logoPath}" alt="Brand Logo" style="max-height: 80px; max-width: 256px; object-fit: contain;" />
				</div>
			`;

			// Insert logo display after the first paragraph in the logo section
			return (
				logoSection.replace(
					/(<p style="margin: 8px 0; line-height: 1.6; color: #333333;">.*?<\/p>)/s,
					`$1${logoDisplay}`
				) + nextSection
			);
		}
	);
}

// Helper function to integrate visual elements into text content
function integrateVisualElementsIntoText(content: string): string {
	const colorInfo = extractColorInformation(content);
	const typographyInfo = extractTypographyInformation(content);

	let integratedContent = content
		.replace(/<[^>]*>/g, '') // Remove HTML tags
		.replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markers
		.replace(/\*(.*?)\*/g, '$1') // Remove italic markers
		.replace(/#{1,6}\s*/g, '') // Remove markdown headers
		.replace(/\n{3,}/g, '\n\n') // Clean up multiple line breaks
		.trim();

	// Integrate color swatches into color palette sections
	if (colorInfo.length > 0) {
		integratedContent = integratedContent.replace(
			/(.*[Cc]olor.*[Pp]alette.*\n.*?)(\n\n.*[A-Z]|\n\n.*\d\.|$)/gs,
			(match, colorSection, nextSection) => {
				const colorSwatches = colorInfo
					.map(
						(color) =>
							`  ${color.name}: ${color.hex}\n` +
							`    RGB: ${color.rgb}\n` +
							`    CMYK: ${color.cmyk}\n` +
							`    Usage: ${color.usage}`
					)
					.join('\n\n');

				return colorSection + '\n\nColor Swatches:\n' + colorSwatches + '\n\n' + nextSection;
			}
		);
	}

	// Integrate typography showcases into typography sections
	if (typographyInfo.length > 0) {
		integratedContent = integratedContent.replace(
			/(.*[Tt]ypography.*\n.*?)(\n\n.*[A-Z]|\n\n.*\d\.|$)/gs,
			(match, typographySection, nextSection) => {
				const typographyShowcase = typographyInfo
					.map(
						(font) =>
							`  ${font.name}\n` +
							`    Usage: ${font.usage}\n` +
							`    Weights: ${font.weights}\n` +
							`    Sample: ${font.sample}`
					)
					.join('\n\n');

				return (
					typographySection + '\n\nFont Showcase:\n' + typographyShowcase + '\n\n' + nextSection
				);
			}
		);
	}

	return integratedContent;
}
